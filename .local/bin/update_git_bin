#!/usr/bin/env python3
"""
If somehow someone finds this code to be even mildy intresting,
or even considring using this for personal use, not to mention production use.
Please re-think about your life choices.
"""
import logging
import os
import pathlib
import shlex
import string
import subprocess
from typing import Optional, Tuple

logging.basicConfig(format="[%(levelname)s]\t%(message)s", level=logging.DEBUG)

CONFIG = {"rel_opt_path": pathlib.Path(".local/opt/")}
REPOS_MAIN_BRANCH = {"bottom": "master", "starship": "master"}
GIT_BASE_COMMAND_TEMPLATE = string.Template(
    'git --git-dir="$git_dir" --work-tree="$repo_path" $git_command'
)
COMMAND_TEMPLATE = {
    "git": {
        "checkout": string.Template(
            GIT_BASE_COMMAND_TEMPLATE.safe_substitute(
                git_command="reset --hard $target"
            )
        ),
        "fetch": string.Template(
            GIT_BASE_COMMAND_TEMPLATE.safe_substitute(git_command="fetch origin --tags")
        ),
        "latest_tag": string.Template(
            GIT_BASE_COMMAND_TEMPLATE.safe_substitute(
                git_command="describe --tags $$(git rev-list --tags --max-count=1)"
            )
        ),
    },
    "rust": {"build": "cargo build --release", "update": "cargo update"},
}


OPT_PATH = pathlib.Path.home() / CONFIG["rel_opt_path"]


class Colors:
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    CVIOLET = "\033[35m"


def main():
    for child in sorted(OPT_PATH.iterdir()):
        if child.is_file():
            continue

        logging.info(f"Updating: {Colors.OKCYAN}{child.name}{Colors.ENDC}")
        if is_git_dir(child):
            os.chdir(str(child))
            fetch_origin(child)
            tag = latest_tag(child)
            if tag is None:
                target = ""
            else:
                target = tag

            git_checkout(path=child, target=target)

        if is_rust_repo(child):
            update_rust_repo(child)


def git_dir_repo(path: pathlib.Path) -> Tuple[str, str]:
    """
    Returns the git directory and the .git path of a git repository.

    Parameters
    ----------
    path : pathlib.Path
        The git repository path.

    Returns
    -------
    str
        The .git directory path of a git repository.
    str
        The path of the git repository.
    """
    git_dir = str(path / ".git")
    repo_path = str(path)

    return (git_dir, repo_path)


def git_checkout(path: pathlib.Path, target: str):
    """
    Performs a 'git checkout' on a git repository.

    Parameters
    ----------
    path : pathlib.Path
        The path of the git repository to perform the checkout on.
    target : str
        The branch/tag to checkout.
    """
    git_dir, repo_path = git_dir_repo(path)
    checkout_command = COMMAND_TEMPLATE["git"]["checkout"].substitute(
        git_dir=str(git_dir), repo_path=repo_path, target=target
    )

    logging.debug(f"Performing checkout on: {path.name} with the target of {target}")
    checkout_command_exit_status = run_n_wait(command=checkout_command)

    if checkout_command_exit_status != 0:
        logging.warning(
            f"{Colors.FAIL}Performing checkout for:{Colors.ENDC}"
            f" {Colors.CVIOLET}{path.name}{Colors.ENDC}"
            f" with the target of {Colors.CVIOLET}{target}{Colors.ENDC}"
            f" {Colors.FAIL}Failed!{Colors.ENDC}"
        )


def fetch_origin(path: pathlib.Path):
    """
    Fetch the origin of a git dir.

    Parameters
    ----------
    path : pathlib.Path
        The git repository path to fetch it's origin.
    """
    git_dir, repo_path = git_dir_repo(path)

    fetch_command = COMMAND_TEMPLATE["git"]["fetch"].substitute(
        git_dir=str(git_dir), repo_path=repo_path
    )

    logging.info(f"{Colors.OKBLUE}Fetching origin{Colors.ENDC}")
    fetch_command_exit_status = run_n_wait(command=fetch_command)

    if fetch_command_exit_status != 0:
        logging.warning(
            f"{Colors.FAIL}Fetching HEAD for:{Colors.ENDC}"
            f" {Colors.CVIOLET}{path.name}{Colors.ENDC}"
            f" {Colors.FAIL}Failed!{Colors.ENDC}"
        )


def latest_tag(path: pathlib.Path) -> Optional[str]:
    """
    Get the latest tag of a git repository.

    Parameters
    ----------
    path : pathlib.Path
        The git repository path to check.

    Returns
    -------
    str or None
        The latest tag, if there is no tags, None is returned.
    """
    git_dir, repo_path = git_dir_repo(path)

    command = COMMAND_TEMPLATE["git"]["latest_tag"].substitute(
        git_dir=git_dir, repo_path=repo_path
    )

    output = ""
    failed = False
    try:
        with subprocess.Popen(
            command,
            shell=True,
            stderr=subprocess.STDOUT,
            stdout=subprocess.PIPE,
            bufsize=1,
            universal_newlines=True,
        ) as subp:
            subp.wait()
            for line in subp.stdout:
                output += line

    except subprocess.CalledProcessError:
        logging.debug(f"{Colors.FAIL}Got subprocces.CalledProcessError{Colors.ENDC}")
        failed = True
    if failed:
        return None
    print("\n" * 5)
    print(output.strip().split("\n"))
    print("\n" * 5)
    result = output.strip().split("\n")[-1]
    return result


def is_git_dir(path: pathlib.Path) -> bool:
    """
    Checks if the directory is a git dir.

    Parameters
    ----------
    path : pathlib.Path
        The path of the directory to check.

    Returns
    -------
    Whether or not the directory is a git directory.
    """
    for child in path.iterdir():
        if child.name == ".git" and child.is_dir():
            return True
    return False


def is_rust_repo(path: pathlib.Path) -> bool:
    """
    Checks if the directory is a rust repository.

    Parameters
    ----------
    path : pathlib.Path
        The path of the directory to check.

    Returns
    -------
    Whether or not the directory is a rust repository.
    """
    cargo_toml = path / "Cargo.toml"
    return cargo_toml.exists() and cargo_toml.is_file()


def run_n_wait(command: str, *, print_output: bool = False) -> int:
    """
    Run a command and wait for it to finish.

    Parameters
    ----------
    command : str
        The command to run.
    print_output : bool, default False
        Whether print the command output to the screen.

    Returns
    -------
    int
        Exit code of the command.
    """
    command_args = shlex.split(command)
    try:
        with subprocess.Popen(
            command_args, stdout=subprocess.PIPE, bufsize=1, universal_newlines=True
        ) as command_process:
            command_process.wait()
            if print_output:
                for line in command_process.stdout:
                    print(line, end="")

        return command_process.returncode
    except subprocess.CalledProcessError:
        logging.error(f"{Colors.FAIL}Failed!{Colors.ENDC}")

    return 1


def cargo_update(path: pathlib.Path):
    """
    foo bar baz
    """
    os.chdir(str(path))
    update_command = COMMAND_TEMPLATE["rust"]["update"]
    update_command_args = shlex.split(update_command)

    with subprocess.Popen(
        command_args, stdout=subprocess.PIPE, bufsize=1, universal_newlines=True
    ) as command_process:
        command_process.wait()
        for line in command_process.stdout:
            print(line, end="")

    if command_process.returncode != 0:
        logging.warning(
            f"{Colors.FAIL}Updating project deps of:{Colors.ENDC}"
            f" {Colors.CVIOLET}{path.name}{Colors.ENDC}"
            f" {Colors.FAIL}Failed!{Colors.ENDC}"
        )


def cargo_build(path: pathlib.Path):
    """
    foo bar baz
    """
    os.chdir(str(path))
    build_command = COMMAND_TEMPLATE["rust"]["build"]
    build_command_args = shlex.split(build_command)
    with subprocess.Popen(
        build_command_args, stdout=subprocess.PIPE, bufsize=1, universal_newlines=True
    ) as command_process:
        for line in command_process.stdout:
            print(line, end="")

    if command_process.returncode != 0:
        logging.warning(
            f"{Colors.FAIL}Building the binary in{Colors.ENDC}"
            f" {Colors.CVIOLET}{path.name}{Colors.ENDC}"
            f" {Colors.FAIL}Failed!{Colors.ENDC}"
        )


def update_rust_repo(path: pathlib.Path):
    """
    Update a rust repository.

    Parameters
    ----------
    path : pathlib.Path
        The path of the directory to update.
    """
    os.chdir(str(path))

    update_command = COMMAND_TEMPLATE["rust"]["update"]
    update_command_exit_status = run_n_wait(command=update_command, print_output=True)

    if update_command_exit_status != 0:
        logging.warning(
            f"{Colors.FAIL}Updating project deps of:{Colors.ENDC}"
            f" {Colors.CVIOLET}{path.name}{Colors.ENDC}"
            f" {Colors.FAIL}Failed!{Colors.ENDC}"
        )

    build_command = COMMAND_TEMPLATE["rust"]["build"]
    build_command_exit_status = run_n_wait(command=build_command, print_output=True)
    if build_command_exit_status != 0:
        logging.warning(
            f"{Colors.FAIL}Building the binary in{Colors.ENDC}"
            f" {Colors.CVIOLET}{path.name}{Colors.ENDC}"
            f" {Colors.FAIL}Failed!{Colors.ENDC}"
        )


if __name__ == "__main__":
    main()
