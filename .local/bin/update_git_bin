#!/usr/bin/env python3
"""
If somehow someone finds this code to be even mildy intresting,
or even considring using this for personal use, not to mention production use.
Please re-think about your life choices.
"""
import pathlib
import string
import logging
import shelx
import subprocess
from pprint import pprint as print

logging.basicConfig(format="[%(levelname)s]\t%(message)s", level=logging.DEBUG)

CONFIG = {"rel_opt_path": pathlib.Path(".local/opt/")}
REPOS_MAIN_BRANCH = {"bottom": "master", "starship": "master"}
COMMAND_TEMPLATE = {
    "git": {
        "fetch": string.Template(
            "git --git-dir=$git_dir --work-tree=$repo_path fetch origin"
        ),
        "pull": string.Template(
            "git"
            " --git-dir=$git_dir"
            " --work-tree=$repo_path"
            " reset --hard origin $branch_name"
        ),
    }
}

OPT_PATH = pathlib.Path.home() / CONFIG["rel_opt_path"]


class Colors:
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    CVIOLET = "\033[35m"


def main():
    for child in OPT_PATH.iterdir():
        if child.is_file:
            continue

        if is_git_dir(child):
            update_git_dir(child)


def update_git_dir(path: pathlib.Path) -> None:
    """
    Update a remote git dir.

    Parameters
    ----------
    path : pathlib.Path
        The path of the directory to update.
    """
    git_dir = str(path / ".git")
    repo_path = str(path)
    # "git --git-dir=$git_dir --work-tree=$repo_path fetch origin"
    fetch_command = COMMAND_TEMPLATE["git"]["fetch"].substitute(
        git_dir=str(git_dir), repo_path=repo_path
    )
    fetch_command_args = shlex.split(fetch_command)
    fetch_command_proccess = subprocess.Popen(
        fetch_command_args, stdout=subprocess.PIPE, bufsize=1, universal_newlines=True
    )
    for line in fetch_command_proccess.stdout:
        print(line, end="")
    fetch_command_proccess.wait()

    if fetch_command_proccess.returncode == 0:
        branch_name = REPOS_MAIN_BRANCH[path.name]
        pull_command = COMMAND_TEMPLATE["git"]["pull"].substitute(
            git_dir=str(git_dir), repo_path=repo_path, branch_name=branch_name
        )
        pull_command_args = shlex.split(pull_command)

        with subprocess.Popen(
            pull_command_args,
            stdout=subprocess.PIPE,
            bufsize=1,
            universal_newlines=True,
        ) as pull_command_proccess:
            for line in pull_command_proccess.stdout:
                print(line, end="")

        if pull_command_proccess.returncode != 0:
            logging.warning(
                f"{Colors.FAIL}Pulling:{Colors.ENDC}"
                f" {Colors.CVIOLET}{path.name}{Colors.ENDC}"
                f" {Colors.FAIL}Failed!{Colors.ENDC}"
            )


    else:
        logging.warning(
            f"{Colors.FAIL}Fetching HEAD for:{Colors.ENDC}"
            f" {Colors.CVIOLET}{path.name}{Colors.ENDC}"
            f" {Colors.FAIL}Failed!{Colors.ENDC}"
        )


def is_git_dir(path: pathlib.Path) -> bool:
    """
    Checks if the directory is a git dir.

    Parameters
    ----------
    path : pathlib.Path
        The path of the directory to check.

    Returns
    -------
    Whether or not the directory is a git directory.
    """
    for child in path.iterdir():
        if child.name == ".git" and child.is_dir():
            return True
    return False


if __name__ == "__main__":
    main()
