#!/usr/bin/env python3
# TODO:
# Refactor the hell out of this
# Use clearer names, like "venv_name" instead of dirname and such
import concurrent.futures
import json
import pprint
import multiprocessing as mp
import pathlib
import logging
import shlex
import string
import subprocess
import time
from typing import Iterable, Optional, Tuple

logging.basicConfig(format="[%(levelname)s]\t%(message)s", level=logging.DEBUG)

COLORS = {
    "blue": "\033[94m",
    "cyan": "\033[96m",
    "green": "\033[92m",
    "yellow": "\033[93m",
    "red": "\033[91m",
}

_CONFIG = {
    "command_template": {
        "base_update": string.Template(
            "$python_bin_path -m pip install --upgrade $dep"
        ),
        "create_virtual_environment": string.Template(
            '$python_bin_path -m venv --prompt "$prompt" $destination_path'
        ),
    },
    "processes": 7,
    "virtual_environments_requirements_directory_name": ".requirements",
    "virtual_environments_directory_name": ".venvs",
    "virtual_environments_metadata_file_name": "settings.json",
    "virtual_environments_metadata": {},
}


def _gen_config(config: dict) -> dict:
    """
    Generate a new config from the given configuration.

    It will:
        * Make all the paths absolute.
        * Load the metadata of the virtual environments.

    Parameters
    ----------
    config : dict
        The current config.

    Returns
    -------
    dict
        The modified config.
    """
    new_config = {}

    new_config["command_template"] = config["command_template"]

    venvs_dir_name = config["virtual_environments_directory_name"]
    abs_venvs_dir_path = pathlib.Path.home() / venvs_dir_name
    new_config["virtual_environments_directory_path"] = abs_venvs_dir_path.resolve()

    reqs_dir_name = config["virtual_environments_requirements_directory_name"]
    abs_reqs_dir_path = abs_venvs_dir_path / reqs_dir_name
    new_config[
        "virtual_environments_requirements_directory_path"
    ] = abs_reqs_dir_path.resolve()

    venvs_metadata_file_name = config["virtual_environments_metadata_file_name"]
    abs_venvs_metadata_file_path = abs_venvs_dir_path / venvs_metadata_file_name
    new_config[
        "virtual_environments_metadata_file_path"
    ] = abs_venvs_metadata_file_path.resolve()

    with new_config["virtual_environments_metadata_file_path"].open(
        mode="r"
    ) as venvs_metadata_file_obj:
        venvs_metadata = json.load(venvs_metadata_file_obj)

    new_config["virtual_environments_metadata"] = venvs_metadata

    return new_config


def colored(text: str, color: str) -> str:
    """
    Format text with colors.

    Parameters
    ----------
    text : str
        Text to be formatted.
    color : {blue, cyan, green, red, yellow}
        Color to be formatted with

    Returns
    -------
    str
        Formmated text.
    """
    END_COLOR = "\033[0m"
    selected_color = COLORS[color.lower()]
    return f"{selected_color}{text}{END_COLOR}"


def create_venv(config: dict, target: str, prompt: Optional[str] = None) -> None:
    """
    Create a virtual environment.

    Parameters
    ----------
    config : dict
        Configuration for the function.
    prompt : str, optional
        Prompt for the virtual environment.
    target : str
        Target virtual environment.
    """
    virtual_environments_directory = config["virtual_environments_directory_path"]
    _, venv_name = gen_venv_req_names(target)
    venv_path = virtual_environments_directory / venv_name

    if venv_path.exists() and venv_path.is_dir():
        logging.debug(
            "Virtual environment for"
            f" {colored(venv_name.removesuffix('-venv'), 'green')}"
            " already exist!\tnot creating a virtual environment..."
        )
        return None

    if prompt is None:
        prompt = target.replace("_", "-")

    create_venv_command_template = config["command_template"][
        "create_virtual_environment"
    ]
    create_venv_command = create_venv_command_template.substitute(
        python_bin_path="/usr/bin/python3", prompt=prompt, destination_path=venv_path
    )
    logging.debug(f"Create virtual environment command: {create_venv_command}")

    escaped_command = shlex.split(create_venv_command)
    subprocess.call(escaped_command)


def gen_venv_req_names(target: str) -> Tuple[str, str]:
    """
    The corresponding req and venv names.

    Parameters
    ----------
    target : str
        Target name.

    Returns
    -------
    str
        requirements name.
    str
        Virtual environment name.
    """
    req_name = f"{target}_requirements.txt"
    venv_name = target.replace("-", "_")
    venv_name = f"{venv_name}-venv"

    return (req_name, venv_name)


def main(config: dict) -> None:
    """
    the main entry point of the script.

    parameters
    ----------
    config : dict
        configuration for the application.
    """
    setup(config=config)
    # update_venvs()


def setup(config: dict) -> None:
    """
    Setup the venvs structure.

    It will:
        * Create the virtual environments requirements direcory.
        * Populate the requirements directory with requirements files.
        * Create virtual environments according to the venvs metadata.

    Parameters
    ----------
    config : dict
        Configuration for the application.
    """
    virtual_environments_requirements_directory = config[
        "virtual_environments_requirements_directory_path"
    ]
    virtual_environments_requirements_directory.mkdir(exist_ok=True)
    with concurrent.futures.ProcessPoolExecutor() as executor:
        for desired_venv_name in sorted(config["virtual_environments_metadata"]):
            executor.submit(create_venv, config, desired_venv_name)
            executor.submit(write_requirements_file, config, desired_venv_name)

def write_requirements_file(config: dict, target: str) -> None:
    """
    Write the requirements for the virtual environment.

    Parameters
    ----------
    config : dict
        Configuration for the function.
    target : str
        Virtual environmnet target.
    """
    virtual_environments_requirements_directory = config[
        "virtual_environments_requirements_directory_path"
    ]
    req_file_name, _ = gen_venv_req_names(target)
    req_file_path = virtual_environments_requirements_directory / req_file_name

    requirements = "\n".join(req for req in sorted(config["virtual_environments_metadata"][target]["requirements"]))

    with req_file_path.open(mode="w") as requirements_file_obj:
        requirements_file_obj.write(requirements)

if __name__ == "__main__":
    config = _gen_config(_CONFIG)
    logging.debug(f"Config:\t{pprint.pformat(config)}")
    main(config=config)


#################################################
#################################################
#################################################
#################################################
#################################################
#################################################
#################################################
#################################################
#################################################
#################################################


def __old_req_file(venv_path: pathlib.Path) -> pathlib.Path:
    """
    Get the requirements file path of a virtual environment.
    """
    requirements_dir = settings["requirements_directory"]
    target = venv_path.name.removesuffix("-venv").replace("_", "-")
    return settings["venvs_dir"] / requirements_dir / f"{target}_requirements.txt"


def __old_update_venv(venv_path: pathlib.Path) -> None:
    """
    foo bar baz
    """
    python_bin_path = venv_path / "bin" / "python3"
    requirements_file_path = req_file(venv_path)
    base_update_command = " && ".join(
        command
        for command in _gen_base_commands(
            template=CONFIG["command_template"]["base_update"],
            python_bin_path=python_bin_path,
        )
    )
    requirements_update_command = f"{python_bin_path} -m pip install --upgrade --upgrade-strategy 'eager' --requirement {requirements_file_path}"
    full_update_command = f"{base_update_command} && {requirements_update_command}"
    subprocess.call(full_update_command, close_fds=True, shell=True)


def __iter_venv_dirs(path: pathlib.Path) -> Iterable[pathlib.Path]:
    """
    foo bar baz
    """
    for venv_path in sorted(path.iterdir()):
        if not venv_path.is_dir():
            continue
        if venv_path.name.startswith("."):
            continue
        yield venv_path


def __settings() -> dict:
    settings = {
        "settings_file": "settings.json",
        "requirements_directory": ".requirements",
        "venvs_data": {},
        "venvs_dir": pathlib.Path.home() / ".venvs",
    }
    settings["settings_file"] = settings["venvs_dir"] / settings["settings_file"]

    with settings["settings_file"].open(mode="r") as json_file:
        settings["venvs_data"] = json.load(json_file)

    return settings


def __gen_base_commands(template: string.Template, *, python_bin_path) -> Iterable[str]:
    """
    foo bar baz
    """
    for dep in ["wheel", "setuptools", "pip"]:
        yield template.substitute(python_bin_path=python_bin_path, dep=dep)


def __old_write_req(requirements_dir: pathlib.Path, target: str) -> None:
    """
    requirements_dir : pathlib.Path
        Location of the `requirements.txt` files will get stored in.
    target : str
        The virtual environment target.
    venv_data : dict
        Data of the virtual environment.
    """
    req_file = requirements_dir / f"{target}_requirements.txt"
    reqs = "\n".join(
        req for req in sorted(settings["venvs_data"][target]["requirements"])
    )

    logging.debug(f"Writing {reqs} to {req_file}")
    with req_file.open(mode="w") as requirements_file:
        requirements_file.write(reqs)


def __old_create_venv(target: str) -> None:
    """
    foo bar baz
    """
    path = settings["venvs_dir"]
    target = target.replace("-", "_")
    name = f"{target}-venv"
    full_path = path / name

    if full_path.exists():
        return None

    command = f'/usr/bin/python3 -m venv --prompt "{target}" {full_path}'
    command = shlex.split(command)
    subprocess.run(command, close_fds=True)

    return None
