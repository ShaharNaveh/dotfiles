#!/usr/bin/env python3
# TODO:
# Refactor the hell out of this
# Use clearer names, like "venv_name" instead of dirname and such
import concurrent.futures
import json
import pprint
import multiprocessing as mp
import pathlib
import logging
import shlex
import string
import subprocess
import time
from typing import Iterable

logging.basicConfig(format="[%(levelname)s]\t%(message)s", level=logging.DEBUG)

_CONFIG = {
    "command_template": {
        "base_update": string.Template(
            "$python_bin_path -m pip install --upgrade $dep"
        ),
    },
    "processes": 7,
    "virtual_environments_requirements_directory_name": ".requirements",
    "virtual_environments_directory_name": ".venvs",
    "virtual_environments_metadata_file_name": "settings.json",
    "virtual_environments_metadata": {},
}

# CONFIG = _CONFIG.copy() # DELETE THIS!


def _gen_config(config: dict) -> dict:
    """
    Generate a new config from the given configuration.

    It will:
    * Make all the paths absolute.
    * Load the metadata of the virtual environments.

    Parameters
    ----------
    config : dict
        The current config.

    Returns
    -------
    dict
        The modified config.
    """
    new_config = {}

    venvs_dir_name = config["virtual_environments_directory_name"]
    abs_venvs_dir_path = pathlib.Path.home() / venvs_dir_name
    new_config["virtual_environments_directory_path"] = abs_venvs_dir_path.resolve()

    reqs_dir_name = config["virtual_environments_requirements_directory_name"]
    abs_reqs_dir_path = abs_venvs_dir_path / reqs_dir_name
    new_config[
        "virtual_environments_requirements_directory_path"
    ] = abs_reqs_dir_path.resolve()

    venvs_metadata_file_name = config["virtual_environments_metadata_file_name"]
    abs_venvs_metadata_file_path = abs_venvs_dir_path / venvs_metadata_file_name
    new_config[
        "virtual_environments_metadata_file_path"
    ] = abs_venvs_metadata_file_path.resolve()

    with new_config["virtual_environments_metadata_file_path"].open(
        mode="r"
    ) as venvs_metadata_file_obj:
        venvs_metadata = json.load(venvs_metadata_file_obj)

    new_config["virtual_environments_metadata"] = venvs_metadata

    return new_config

def _settings() -> dict:
    settings = {
        "settings_file": "settings.json",
        "requirements_directory": ".requirements",
        "venvs_data": {},
        "venvs_dir": pathlib.Path.home() / ".venvs",
    }
    settings["settings_file"] = settings["venvs_dir"] / settings["settings_file"]

    with settings["settings_file"].open(mode="r") as json_file:
        settings["venvs_data"] = json.load(json_file)

    return settings


def _gen_base_commands(template: string.Template, *, python_bin_path) -> Iterable[str]:
    """
    foo bar baz
    """
    for dep in ["wheel", "setuptools", "pip"]:
        yield template.substitute(python_bin_path=python_bin_path, dep=dep)


def write_req(requirements_dir: pathlib.Path, target: str) -> None:
    """
    requirements_dir : pathlib.Path
        Location of the `requirements.txt` files will get stored in.
    target : str
        The virtual environment target.
    venv_data : dict
        Data of the virtual environment.
    """
    req_file = requirements_dir / f"{target}_requirements.txt"
    reqs = "\n".join(
        req for req in sorted(settings["venvs_data"][target]["requirements"])
    )

    logging.debug(f"Writing {reqs} to {req_file}")
    with req_file.open(mode="w") as requirements_file:
        requirements_file.write(reqs)


def create_venv(target: str) -> None:
    """
    foo bar baz
    """
    path = settings["venvs_dir"]
    target = target.replace("-", "_")
    name = f"{target}-venv"
    full_path = path / name

    if full_path.exists():
        return None

    command = f'/usr/bin/python3 -m venv --prompt "{target}" {full_path}'
    command = shlex.split(command)
    subprocess.run(command, close_fds=True)

    return None


def setup(config: dict) -> None:
    """
    Setup the venvs structure.

    It will:
        * Create the virtual environments requirements direcory.
        * Populate the requirements directory with requirements files.
        * Create virtual environments according to the venvs metadata.

    Parameters
    ----------
    config : dict
        Configuration for the application.
    """
    config["virtual_environments_requirements_directory_path"].mkdir(exist_ok=True)

    #req_dir_full_path = settings["venvs_dir"] / settings["requirements_directory"]

    '''
    with concurrent.futures.ProcessPoolExecutor() as executor:
        for dir_name in settings["venvs_data"]:
            executor.submit(write_req, req_dir_full_path, dir_name)
            executor.submit(create_venv, dir_name)
    '''


def req_file(venv_path: pathlib.Path) -> pathlib.Path:
    """
    Get the requirements file path of a virtual environment.
    """
    requirements_dir = settings["requirements_directory"]
    target = venv_path.name.removesuffix("-venv").replace("_", "-")
    return settings["venvs_dir"] / requirements_dir / f"{target}_requirements.txt"


def update_venv(venv_path: pathlib.Path) -> None:
    """
    foo bar baz
    """
    python_bin_path = venv_path / "bin" / "python3"
    requirements_file_path = req_file(venv_path)
    base_update_command = " && ".join(
        command
        for command in _gen_base_commands(
            template=CONFIG["command_template"]["base_update"],
            python_bin_path=python_bin_path,
        )
    )
    requirements_update_command = f"{python_bin_path} -m pip install --upgrade --upgrade-strategy 'eager' --requirement {requirements_file_path}"
    full_update_command = f"{base_update_command} && {requirements_update_command}"
    subprocess.call(full_update_command, close_fds=True, shell=True)


def iter_venv_dirs(path: pathlib.Path) -> Iterable[pathlib.Path]:
    """
    foo bar baz
    """
    for venv_path in sorted(path.iterdir()):
        if not venv_path.is_dir():
            continue
        if venv_path.name.startswith("."):
            continue
        yield venv_path


def update_venvs() -> None:
    """
    foo bar baz.
    """
    with mp.Pool(processes=CONFIG["processes"]) as pool:
        pool.map(update_venv, iter_venv_dirs(path=settings["venvs_dir"]))


def main(config: dict) -> None:
    """
    the main entry point of the script.

    parameters
    ----------
    config : dict
        configuration for the application.
    """
    setup(config=config)
    #update_venvs()


if __name__ == "__main__":
    config = _gen_config(_CONFIG)
    logging.debug(f"Config:\t{pprint.pformat(config)}")
    main(config=config)
