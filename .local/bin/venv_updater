#!/usr/bin/env python3
import json
import logging
import multiprocessing as mp
import pathlib
import pprint
import re
import shlex
import string
import subprocess
from typing import Iterable, Optional, Set, Tuple

logging.basicConfig(format="[%(levelname)s]\t%(message)s", level=logging.INFO)

COLORS = {
    "blue": "\033[94m",
    "cyan": "\033[96m",
    "green": "\033[92m",
    "yellow": "\033[93m",
    "red": "\033[91m",
}

_CONFIG = {
    "bin_dir": pathlib.Path.home() / ".local" / "bin",
    "command_template": {
        "base_update": string.Template(
            "$python_bin_path -m pip install --upgrade $dependency"
        ),
        "create_virtual_environment": string.Template(
            '$python_bin_path -m venv --prompt "$prompt" $destination_path'
        ),
        "requirements_update_command": string.Template(
            "$python_bin_path -m pip install"
            " --upgrade --upgrade-strategy 'eager'"
            " --requirement $requirements_file_path"
        ),
    },
    "processes": 6,
    "virtual_environments_requirements_directory_name": ".requirements",
    "virtual_environments_directory_name": ".venvs",
    "virtual_environments_metadata_file_name": "settings.json",
    "virtual_environments_metadata": {},
}


def _gen_config(config: dict) -> dict:
    """
    Generate a new config from the given configuration.

    It will:
        * Make all the paths absolute.
        * Load the metadata of the virtual environments.

    Parameters
    ----------
    config : dict
        The current config.

    Returns
    -------
    dict
        The modified config.
    """
    new_config = {}

    new_config["bin_dir"] = config["bin_dir"]
    new_config["command_template"] = config["command_template"]
    new_config["processes"] = config["processes"]

    venvs_dir_name = config["virtual_environments_directory_name"]
    abs_venvs_dir_path = pathlib.Path.home() / venvs_dir_name
    new_config["virtual_environments_directory_path"] = abs_venvs_dir_path.resolve()

    reqs_dir_name = config["virtual_environments_requirements_directory_name"]
    abs_reqs_dir_path = abs_venvs_dir_path / reqs_dir_name
    new_config[
        "virtual_environments_requirements_directory_path"
    ] = abs_reqs_dir_path.resolve()

    venvs_metadata_file_name = config["virtual_environments_metadata_file_name"]
    abs_venvs_metadata_file_path = abs_venvs_dir_path / venvs_metadata_file_name
    new_config[
        "virtual_environments_metadata_file_path"
    ] = abs_venvs_metadata_file_path.resolve()

    with new_config["virtual_environments_metadata_file_path"].open(
        mode="r"
    ) as venvs_metadata_file_obj:
        venvs_metadata = json.load(venvs_metadata_file_obj)

    new_config["virtual_environments_metadata"] = venvs_metadata

    return new_config


def colored(text: str, color: str) -> str:
    """
    Format text with colors.

    Parameters
    ----------
    text : str
        Text to be formatted.
    color : {blue, cyan, green, red, yellow}
        Color to be formatted with

    Returns
    -------
    str
        Formmated text.
    """
    END_COLOR = "\033[0m"
    selected_color = COLORS[color.lower()]
    return f"{selected_color}{text}{END_COLOR}"


def create_venv(path: pathlib.Path, prompt: str) -> None:
    """
    Create a virtual environment.

    Parameters
    ----------
    path : pathlib.Path
        Path to the virtual environment dir.
    prompt : str
        Prompt for the new virtual environment.
    """
    create_venv_command_template = config["command_template"][
        "create_virtual_environment"
    ]
    create_venv_command = create_venv_command_template.substitute(
        python_bin_path="/usr/bin/python3", prompt=prompt, destination_path=path
    )
    logging.debug(f"Create virtual environment command: {create_venv_command}")

    escaped_command = shlex.split(create_venv_command)
    subprocess.run(escaped_command)


def gen_base_upgrade_commands(python_bin_path: str) -> Iterable[str]:
    """
    Generate base upgrade commands.

    Parameters
    ----------
    python_bin_path : str
        Path to python executble.

    Yields
    ------
    str
        Base upgrade command.
    """
    for dependency in ["wheel", "setuptools", "pip"]:
        yield config["command_template"]["base_update"].substitute(
            python_bin_path=python_bin_path, dependency=dependency
        )


def gen_venv_req_names(target: str) -> Tuple[str, str]:
    """
    The corresponding req and venv names.

    Parameters
    ----------
    target : str
        Target name.

    Returns
    -------
    str
        requirements name.
    str
        Virtual environment name.
    """
    req_name = f"{target}_requirements.txt"
    venv_name = target.replace("-", "_")
    venv_name = f"{venv_name}-venv"

    return (req_name, venv_name)


def link_bin(venv_path: pathlib.Path, bin_name: str):
    """
    foo bar baz.
    """
    bin_path = venv_path / "bin" / bin_name
    target_path = config["bin_dir"] / bin_name
    if target_path.is_symlink():
        return None
    target_path.symlink_to(bin_path)


def magic(target: str) -> None:
    req_file_name, venv_dir_name = gen_venv_req_names(target=target)
    req_file_path = (
        config["virtual_environments_requirements_directory_path"] / req_file_name
    )
    write_reqs(target=target, path=req_file_path)
    venv_dir_path = config["virtual_environments_directory_path"] / venv_dir_name
    if not venv_dir_path.is_dir():
        create_venv(path=venv_dir_path, prompt=target)
    update_venv(venv_dir_path=venv_dir_path, reqs_path=req_file_path, target=target)

    try:
        bins = config["virtual_environments_metadata"][target]["bins"]
    except KeyError:
        bins = None

    if bins is not None:
        for bin_to_link in bins:
            link_bin(venv_path=venv_dir_path, bin_name=bin_to_link)


def main(config: dict):
    config["virtual_environments_requirements_directory_path"].mkdir(exist_ok=True)

    with mp.Pool(processes=config["processes"]) as pool:
        pool.map(magic, sorted(config["virtual_environments_metadata"]))


def update_venv(
    venv_dir_path: pathlib.Path, reqs_path: pathlib.Path, target: str
) -> None:
    """
    Update a virtual environment.

    Parameters
    ----------
    venv_dir_path : pathlib.Path
        Path to the virtual environment directory.
    reqs_path : pathlib.Path
        Path to the reqs file.
    target : str
        Name of the target, used only for logging purposes.
    """
    python_bin_path = venv_dir_path / "bin" / "python3"
    base_upgrade_command = " && ".join(
        command
        for command in gen_base_upgrade_commands(python_bin_path=python_bin_path)
    )
    requirements_update_command = config["command_template"][
        "requirements_update_command"
    ].substitute(python_bin_path=python_bin_path, requirements_file_path=reqs_path)

    full_command = f"{base_upgrade_command} && {requirements_update_command}"
    with subprocess.Popen(
        full_command,
        shell=True,
        stderr=subprocess.PIPE,
        stdout=subprocess.PIPE,
    ) as proc:
        outs, errs = proc.communicate()

    logging.info(f"Done upgrading virtual environment of:\t{colored(target, 'green')}")




def write_reqs(target: str, path: pathlib.Path) -> None:
    """
    Write the requirements for the virtual environment.

    Parameters
    ----------
    target : str
        Virtual environmnet target.
    path : pathlib.Path
        Path to the requirements.txt file.
    """
    requirements = "\n".join(
        req
        for req in sorted(
            config["virtual_environments_metadata"][target]["requirements"]
        )
    )

    with path.open(mode="w") as requirements_file_obj:
        requirements_file_obj.write(requirements)


if __name__ == "__main__":
    config = _gen_config(_CONFIG)
    logging.debug(f"Config:\t{pprint.pformat(config)}")
    main(config=config)
